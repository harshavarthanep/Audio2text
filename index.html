<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clean Speech Studio</title>
    <style>
        :root {
            --primary: #6366f1; /* Indigo */
            --primary-dark: #4f46e5;
            --accent: #ec4899; /* Pink */
            --bg: #f3f4f6;
            --surface: #ffffff;
            --text-dark: #1f2937;
            --text-gray: #6b7280;
            --border: #e5e7eb;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg);
            color: var(--text-dark);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 900px;
            background: var(--surface);
            border-radius: 16px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 90vh; /* Fixed height for app feel */
        }

        /* --- Header --- */
        header {
            padding: 1.5rem;
            background: white;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        header h1 { margin: 0; font-size: 1.25rem; font-weight: 700; color: var(--primary-dark); }
        .status-pill {
            font-size: 0.85rem;
            padding: 4px 12px;
            border-radius: 20px;
            background: #f3f4f6;
            color: var(--text-gray);
            font-weight: 600;
        }

        /* --- Main Layout --- */
        .main-area {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 1.5rem;
            gap: 1rem;
        }

        /* --- Upload & Audio Player --- */
        .media-controls {
            background: #f9fafb;
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        
        .file-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        audio { width: 100%; height: 40px; margin-top: 5px; border-radius: 20px; }

        /* --- Editor (The Fix) --- */
        .editor-container {
            flex: 1;
            position: relative;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: white;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* We use a div, not a textarea, to style the "Ghost" text differently */
        #outputDisplay {
            flex: 1;
            padding: 1.5rem;
            overflow-y: auto;
            font-size: 1.1rem;
            line-height: 1.6;
            outline: none;
            white-space: pre-wrap;
        }

        .final-text { color: var(--text-dark); }
        .interim-text { color: #9ca3af; font-style: italic; }

        /* --- Action Bar --- */
        .action-bar {
            padding: 1.5rem;
            background: white;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 0.75rem 1.25rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
        }

        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-dark); }
        
        .btn-danger { background: #ef4444; color: white; display: none; }
        
        .btn-secondary { background: white; border: 1px solid var(--border); color: var(--text-dark); }
        .btn-secondary:hover { border-color: var(--primary); color: var(--primary); }

        .btn-tool { background: #f3f4f6; color: var(--text-dark); }
        
        .spacer { flex: 1; }

        @media (max-width: 700px) {
            .action-bar { flex-direction: column; align-items: stretch; }
            .file-row { flex-direction: column; align-items: stretch; }
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>üéôÔ∏è Clean Speech Studio</h1>
        <div id="status" class="status-pill">Ready</div>
    </header>

    <div class="main-area">
        <div class="media-controls">
            <div class="file-row">
                <button class="btn-secondary" onclick="document.getElementById('audioInput').click()">
                    üìÇ Upload Audio File
                </button>
                <input type="file" id="audioInput" accept="audio/*" style="display: none">
                
                <button class="btn-secondary" id="modeBtn" onclick="toggleMicMode()">
                    üé§ Switch to Microphone
                </button>
            </div>
            <div id="fileName" style="font-size: 0.85rem; color: var(--primary);"></div>
            <audio id="audioPlayer" controls style="display:none"></audio>
        </div>

        <div class="editor-container">
            <div id="outputDisplay" contenteditable="true" spellcheck="false"></div>
        </div>
    </div>

    <div class="action-bar">
        <button id="startBtn" class="btn-primary" onclick="startProcess()">
            <span>‚ñ∂ Start Transcribing</span>
        </button>
        <button id="stopBtn" class="btn-danger" onclick="stopProcess()">
            <span>‚èπ Stop</span>
        </button>

        <div class="spacer"></div>

        <button class="btn-tool" onclick="speakText()">üîä Read Aloud</button>
        <button class="btn-tool" onclick="copyText()">üìã Copy</button>
        <button class="btn-tool" onclick="downloadDoc()">üíæ Download Word</button>
        <button class="btn-tool" onclick="clearAll()">üóëÔ∏è</button>
    </div>
</div>

<script>
    // --- State Management ---
    const state = {
        isRecording: false,
        isMicMode: false,
        permanentText: "", // Confirmed text
        interimText: "",   // Flickering guess text
        recognition: null,
        ignoreEnd: false
    };

    // --- DOM Elements ---
    const els = {
        display: document.getElementById('outputDisplay'),
        audioPlayer: document.getElementById('audioPlayer'),
        audioInput: document.getElementById('audioInput'),
        startBtn: document.getElementById('startBtn'),
        stopBtn: document.getElementById('stopBtn'),
        status: document.getElementById('status'),
        modeBtn: document.getElementById('modeBtn'),
        fileName: document.getElementById('fileName')
    };

    // --- Speech Initialization ---
    function initSpeech() {
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
            alert("Browser not supported. Please use Google Chrome or Edge.");
            return;
        }
        
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'en-US';

        recognition.onstart = () => {
            state.isRecording = true;
            updateUI(true);
            els.status.innerText = state.isMicMode ? "Listening..." : "Transcribing File...";
            els.status.style.color = "var(--primary)";
        };

        recognition.onend = () => {
            state.isRecording = false;
            // Auto-restart if file is still playing (Loopback hack)
            if (!state.isMicMode && !els.audioPlayer.paused && !state.ignoreEnd) {
                recognition.start();
            } else {
                updateUI(false);
                els.status.innerText = "Stopped";
                els.status.style.color = "var(--text-gray)";
            }
            state.ignoreEnd = false;
        };

        recognition.onerror = (e) => {
            console.log(e.error);
            if (e.error === 'no-speech') state.ignoreEnd = true;
        };

        // *** THE FIX: LOGIC TO PREVENT REPETITION ***
        recognition.onresult = (event) => {
            let newFinal = "";
            let newInterim = "";

            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    newFinal += event.results[i][0].transcript + " ";
                } else {
                    newInterim += event.results[i][0].transcript;
                }
            }

            // Update State
            state.permanentText += newFinal;
            state.interimText = newInterim;

            // Render to DOM (Visual separation)
            renderText();
        };

        return recognition;
    }

    state.recognition = initSpeech();

    // --- Rendering Logic (Prevents Stutter) ---
    function renderText() {
        // We do NOT use innerText += ...
        // We wipe the display and repaint it: Final (Black) + Interim (Gray)
        
        // 1. Save cursor position (optional but good for UX, simplified here)
        
        // 2. Build HTML
        // Note: We use the global 'state.permanentText' which is only updated on Final results.
        const html = `<span class="final-text">${state.permanentText}</span><span class="interim-text">${state.interimText}</span>`;
        
        els.display.innerHTML = html;
        
        // 3. Auto Scroll
        els.display.scrollTop = els.display.scrollHeight;
    }

    // --- Event Listeners ---
    
    // Handle Manual Edits (If user types, we must update state.permanentText)
    els.display.addEventListener('input', () => {
        state.permanentText = els.display.innerText;
        state.interimText = ""; // Clear interim if user edits
    });

    els.audioInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const url = URL.createObjectURL(file);
            els.audioPlayer.src = url;
            els.audioPlayer.style.display = 'block';
            els.fileName.innerText = "Loaded: " + file.name;
            
            // Force file mode
            state.isMicMode = false;
            els.modeBtn.innerText = "üé§ Switch to Microphone";
            els.status.innerText = "File Loaded. Press Start.";
        }
    });

    // --- Controls ---

    function startProcess() {
        if (!state.recognition) return;
        
        if (state.isMicMode) {
            state.recognition.start();
        } else {
            if (!els.audioPlayer.src) {
                alert("Please upload a file first!");
                return;
            }
            els.audioPlayer.play();
            state.recognition.start();
        }
    }

    function stopProcess() {
        state.ignoreEnd = true;
        if (state.recognition) state.recognition.stop();
        if (!state.isMicMode) els.audioPlayer.pause();
    }

    function toggleMicMode() {
        state.isMicMode = !state.isMicMode;
        stopProcess();

        if (state.isMicMode) {
            els.audioPlayer.style.display = 'none';
            els.fileName.innerText = "";
            els.modeBtn.innerText = "üìÇ Switch to File Upload";
            els.status.innerText = "Mic Mode Ready";
        } else {
            els.audioPlayer.style.display = els.audioPlayer.src ? 'block' : 'none';
            els.modeBtn.innerText = "üé§ Switch to Microphone";
            els.status.innerText = "File Mode Ready";
        }
    }

    function updateUI(recording) {
        if (recording) {
            els.startBtn.style.display = 'none';
            els.stopBtn.style.display = 'flex';
            els.display.style.borderColor = "var(--primary)";
        } else {
            els.startBtn.style.display = 'flex';
            els.stopBtn.style.display = 'none';
            els.display.style.borderColor = "var(--border)";
        }
    }

    // --- Output Features ---

    function clearAll() {
        if(confirm("Clear all text?")) {
            state.permanentText = "";
            state.interimText = "";
            renderText();
        }
    }

    function copyText() {
        const text = els.display.innerText;
        navigator.clipboard.writeText(text);
        const original = els.status.innerText;
        els.status.innerText = "Copied!";
        setTimeout(() => els.status.innerText = original, 1500);
    }

    function speakText() {
        const text = els.display.innerText;
        if(!text) return;
        
        // Native Browser TTS
        window.speechSynthesis.cancel(); // Stop previous
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1;
        utterance.pitch = 1;
        window.speechSynthesis.speak(utterance);
        
        els.status.innerText = "Reading Aloud...";
        utterance.onend = () => els.status.innerText = "Finished Reading";
    }

    function downloadDoc() {
        const text = els.display.innerText;
        if (!text) { alert("No text to download"); return; }

        const header = `<html xmlns:o='urn:schemas-microsoft-com:office:office' 
                        xmlns:w='urn:schemas-microsoft-com:office:word' 
                        xmlns='http://www.w3.org/TR/REC-html40'>
                        <head><meta charset='utf-8'><title>Transcript</title></head><body>`;
        const footer = "</body></html>";
        const html = header + text.replace(/\n/g, "<br>") + footer;

        const blob = new Blob(['\ufeff', html], { type: 'application/msword' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `Transcript_${Date.now()}.doc`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    // Initial render
    renderText();

</script>
</body>
</html>
